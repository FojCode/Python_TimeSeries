
# linear filters of a time series 
import numpy as np
from scipy.signal import filtfilt, butter, iirfilter

def moving_average_filter(data, window_size):
  """
  This function applies a moving average filter to the time series.

  Args:
      data: A list of numerical values representing the time series.
      window_size: The size of the moving average window (must be odd).

  Returns:
      The filtered time series.
  """
  if window_size % 2 == 0:
    raise ValueError("Window size must be odd for moving average filter.")
  weights = np.ones(window_size) / window_size
  return filtfilt(weights, 1, data)  # filtfilt for causal filtering

def butterworth_filter(data, cutoff_freq, fs, filter_type="lowpass"):
  """
  This function applies a Butterworth filter to the time series.

  Args:
      data: A list of numerical values representing the time series.
      cutoff_freq: The cutoff frequency for the filter (normalized by sampling rate).
      fs: The sampling frequency of the time series.
      filter_type: The type of filter ("lowpass", "highpass", "bandpass", or "bandstop").

  Returns:
      The filtered time series.
  """
  nyq = fs / 2  # Nyquist frequency
  normalized_cutoff = cutoff_freq / nyq
  order, wn = butter(N=None, Wn=normalized_cutoff, btype=filter_type)
  b, a = butter(order, wn)
  return filtfilt(b, a, data)

def iirfilter_design(data, f1, f2, fs, filter_type="bandpass"):
  """
  This function applies a custom IIR filter using the iirfilter function.

  Args:
      data: A list of numerical values representing the time series.
      f1: Lower cutoff frequency for bandpass or bandstop filter (optional).
      f2: Upper cutoff frequency for bandpass or bandstop filter (optional).
      fs: The sampling frequency of the time series.
      filter_type: The type of filter ("lowpass", "highpass", "bandpass", or "bandstop").

  Returns:
      The filtered time series.
  """
  nyq = fs / 2
  if filter_type in ["bandpass", "bandstop"]:
    f1_normalized = f1 / nyq
    f2_normalized = f2 / nyq
    b, a = iirfilter(filter_type, f1=f1_normalized, f2=f2_normalized)
  else:
    cutoff_freq = f1 / nyq  # Assuming f1 is the cutoff frequency for other filter types
    b, a = iirfilter(filter_type, cutoff=cutoff_freq)
  return filtfilt(b, a, data)

# Example usage
data = np.sin(2*np.pi*0.1*np.arange(100)) + np.random.rand(100)  # Sample data with sine wave and noise
fs = 100  # Sampling frequency

# Moving average filter
filtered_data_ma = moving_average_filter(data.copy(), window_size=5)

# Butterworth lowpass filter
cutoff_freq = 0.2  # Normalized cutoff frequency (0 to 0.5)
filtered_data_butter = butterworth_filter(data.copy(), cutoff_freq, fs)

# Custom IIR bandpass filter
f1 = 0.1  # Lower cutoff frequency
f2 = 0.3  # Upper cutoff frequency
filtered_data_iir = iirfilter_design(data.copy(), f1, f2, fs)

# Plot results (using matplotlib)
import matplotlib.pyplot as plt

plt.plot(data, label="Original data")
plt.plot(filtered_data_ma, label="Moving average")
plt.plot(filtered_data_butter, label="Butterworth lowpass")
plt.plot(filtered_data_iir, label="Custom IIR bandpass")
plt.legend()
plt.show()


# Ljung and Box portmanteau test of residuals 
import statsmodels.api as sm

def arma_ljungbox_test(data, p, q, lags=None):
  """
  This function fits an ARMA(p,q) model to the data and performs the Ljung-Box test on the residuals.

  Args:
      data: A list of numerical values representing the time series.
      p: The AR order of the model.
      q: The MA order of the model.
      lags: The number of lags to test (default None, uses a rule based on data length).

  Returns:
      A tuple containing:
          - The Ljung-Box test statistic
          - The p-value for the Ljung-Box test
  """
  model = sm.tsa.ARMA(data, (p, q)).fit(disp=-1)
  lb_results = sm.stats.acorr_ljungbox(model.resid, lags=lags)
  return lb_results.lb_stat[0], lb_results.lb_pvalue[0]

# Example usage
data = [....]  # Replace with your actual time series data
p = 1  # AR order (adjust as needed)
q = 1  # MA order (adjust as needed)
lags = 10  # Number of lags to test (optional)

lb_stat, lb_pvalue = arma_ljungbox_test(data, p, q, lags)

print(f"Ljung-Box test statistic: {lb_stat}")
print(f"Ljung-Box p-value: {lb_pvalue}")

# For Box-Pierce test, use boxpierce=True in acorr_ljungbox function


# Turning point test 
def turning_points(data):
  """
  This function calculates the number of turning points in a time series.

  Args:
      data: A list of numerical values representing the time series.

  Returns:
      The number of turning points in the data.
  """
  turning_points = 0
  for i in range(2, len(data)):
    if (data[i-1] < data[i] and data[i] > data[i+1]) or (data[i-1] > data[i] and data[i] < data[i+1]):
      turning_points += 1
  return turning_points

def turning_point_test(data, alpha=0.05):
  """
  This function performs the turning point test on a time series.

  Args:
      data: A list of numerical values representing the time series.
      alpha: The significance level for the test (default 0.05).

  Returns:
      A tuple containing:
          - The test statistic (number of turning points)
          - The p-value
          - True if the null hypothesis is rejected (data not random)
  """
  n = len(data)
  expected_turning_points = (n - 2) * 2 / 3
  variance = 8 * n / 45
  test_statistic = turning_points(data)
  z_score = (test_statistic - expected_turning_points) / np.sqrt(variance)
  p_value = 1 - (1 - np.erf(z_score / np.sqrt(2))) / 2
  reject_null = p_value < alpha
  return test_statistic, p_value, reject_null

# Example usage
import numpy as np

# Sample time series data
data = np.random.rand(100)

# Perform the turning point test
test_statistic, p_value, reject_null = turning_point_test(data)

print(f"Test statistic: {test_statistic}")
print(f"p-value: {p_value}")

if reject_null:
  print("Reject null hypothesis: The data is not random at a significance level of {alpha}.")
else:
  print("Fail to reject null hypothesis: The data may be random.")
